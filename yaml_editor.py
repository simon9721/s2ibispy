# yaml_editor_final.py — THE ULTIMATE s2ibispy YAML EDITOR
# YOU ARE THE MASTER. THIS IS YOUR LEGACY.

import tkinter as tk
from tkinter import ttk, filedialog, messagebox, scrolledtext
import yaml
from pathlib import Path
from datetime import datetime
import os

# Try to import your netlist parser
try:
    from parse_netlist import parse_netlist
    NETLIST_PARSER_AVAILABLE = True
except ImportError:
    NETLIST_PARSER_AVAILABLE = False
    parse_netlist = None

class S2IbispyEditor:
    def __init__(self, root):
        self.root = root
        self.root.title("s2ibispy YAML Editor — The Ultimate Tool")
        self.root.geometry("1800x1000")
        self.current_file = None
        self.yaml_data = {}
        self.modified = False

        self.setup_ui()
        self.new_file()

    def setup_ui(self):
        style = ttk.Style()
        style.theme_use('clam')

        # Top bar
        top = ttk.Frame(self.root)
        top.pack(fill=tk.X, padx=10, pady=5)
        ttk.Button(top, text="New File", command=self.new_file).pack(side=tk.LEFT, padx=5)
        ttk.Button(top, text="Open YAML", command=self.open_yaml).pack(side=tk.LEFT, padx=5)
        ttk.Button(top, text="Open SPICE Netlist", command=self.open_spice,
                   state="normal" if NETLIST_PARSER_AVAILABLE else "disabled").pack(side=tk.LEFT, padx=5)
        ttk.Button(top, text="Save", command=self.save).pack(side=tk.RIGHT, padx=5)

        # Main split
        paned = ttk.PanedWindow(self.root, orient=tk.HORIZONTAL)
        paned.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        # Left: Tabs
        left = ttk.Frame(paned)
        paned.add(left, weight=3)
        notebook = ttk.Notebook(left)
        notebook.pack(fill=tk.BOTH, expand=True)

        self.tabs = {}
        for name in ["Global", "Models", "Component", "Pins", "Waveforms"]:
            f = ttk.Frame(notebook)
            notebook.add(f, text=name)
            self.tabs[name] = f

        # Right: Live YAML
        right = ttk.Frame(paned)
        paned.add(right, weight=2)
        ttk.Label(right, text="Live YAML Preview", font=("Helvetica", 14, "bold")).pack(anchor="w", padx=10, pady=10)
        self.yaml_preview = scrolledtext.ScrolledText(
            right, font=("Consolas", 11), bg="#1e1e1e", fg="#d4d4d4", insertbackground="white"
        )
        self.yaml_preview.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        # Log
        self.log_widget = scrolledtext.ScrolledText(self.root, height=8, state='disabled')
        self.log_widget.pack(fill=tk.X, side=tk.BOTTOM, padx=10, pady=5)

        # Build all tabs
        self.build_global_tab()
        self.build_models_tab()
        self.build_component_tab()
        self.build_pins_tab()
        self.build_waveforms_tab()

    def log(self, msg, level="info"):
        self.log_widget.config(state='normal')
        colors = {"info": "black", "success": "green", "warning": "orange", "error": "red"}
        self.log_widget.insert(tk.END, f"{datetime.now().strftime('%H:%M:%S')} | {msg}\n", level)
        self.log_widget.tag_config(level, foreground=colors.get(level, "black"))
        self.log_widget.see(tk.END)
        self.log_widget.config(state='disabled')

    def mark_modified(self, *_):
        if not self.modified:
            self.modified = True
            title = self.root.title()
            if not title.startswith("*"):
                self.root.title("*" + title)

    def update_yaml(self):
        try:
            data = self.collect_data()
            yaml_str = yaml.dump(data, sort_keys=False, allow_unicode=True, width=1000, default_flow_style=False)
            self.yaml_preview.delete(1.0, tk.END)
            self.yaml_preview.insert(tk.END, yaml_str)
        except Exception as e:
            self.yaml_preview.delete(1.0, tk.END)
            self.yaml_preview.insert(tk.END, f"# ERROR GENERATING YAML:\n# {e}")

    def collect_data(self):
        data = {
            "ibis_version": self.global_vars["ibis_version"].get(),
            "file_name": self.global_vars["file_name"].get(),
            "file_rev": self.global_vars["file_rev"].get(),
            "date": datetime.now().strftime("%Y-%m-%d"),
            "source": "Generated by s2ibispy YAML Editor",
            "notes": "",
            "copyright": "© 2025",
            "spice_type": "hspice",
            "iterate": 1,
            "cleanup": 0,
            "global_defaults": {
                "temp_range": {"typ": 27, "min": 100, "max": 0},
                "voltage_range": {"typ": 3.3, "min": 3.0, "max": 3.6},
                "pullup_ref": {"typ": 3.3, "min": 3.0, "max": 3.6},
                "pulldown_ref": {"typ": 0, "min": 0, "max": 0},
                "power_clamp_ref": {"typ": 3.3, "min": 3.0, "max": 3.6},
                "gnd_clamp_ref": {"typ": 0, "min": 0, "max": 0},
                "vil": {"typ": 0.8, "min": 0.7, "max": 0.9},
                "vih": {"typ": 2.0, "min": 1.8, "max": 2.2},
                "c_comp": {"typ": 1.2e-12, "min": 1.0e-12, "max": 1.4e-12},
                "r_load": 50.0,
                "sim_time": 6e-9,
            },
            "models": [],
            "components": [{
                "component": "MyBuffer",
                "manufacturer": "Unknown",
                "spiceFile": "buffer.sp",
                "pList": []
            }]
        }

        # Models
        for item in self.models_tree.get_children():
            values = self.models_tree.item(item, "values")
            data["models"].append({
                "name": values[0],
                "type": values[1],
                "enable": values[2] or None,
                "polarity": values[3],
                "rising_waveforms": [{"R_fixture": 50, "V_fixture": 0}, {"R_fixture": 50, "V_fixture": 3.3}],
                "falling_waveforms": [{"R_fixture": 50, "V_fixture": 0}, {"R_fixture": 50, "V_fixture": 3.3}],
            })

        # Pins
        for item in self.pins_tree.get_children():
            values = self.pins_tree.item(item, "values")
            data["components"][0]["pList"].append({
                "pinName": values[0],
                "signalName": values[1],
                "modelName": values[2],
                "inputPin": values[3] or None,
                "enablePin": values[4] or None,
            })

        return data

    def new_file(self):
        self.current_file = None
        self.modified = False
        self.root.title("Untitled — s2ibispy YAML Editor")
        self.log("New file created", "success")
        self.clear_all_tabs()
        self.update_yaml()

    def clear_all_tabs(self):
        for tree in [self.models_tree, self.pins_tree]:
            for item in tree.get_children():
                tree.delete(item)

    def open_yaml(self):
        path = filedialog.askopenfilename(filetypes=[("YAML", "*.yaml *.yml")])
        if not path: return
        try:
            with open(path, 'r') as f:
                content = f.read()
            self.current_file = path
            self.root.title(f"{Path(path).name} — s2ibispy YAML Editor")
            self.yaml_preview.delete(1.0, tk.END)
            self.yaml_preview.insert(tk.END, content)
            self.log(f"Loaded: {Path(path).name}", "success")
            self.modified = False
        except Exception as e:
            messagebox.showerror("Error", f"Cannot open YAML:\n{e}")

    def open_spice(self):
        if not NETLIST_PARSER_AVAILABLE:
            messagebox.showerror("Error", "parse_netlist.py not found")
            return
        path = filedialog.askopenfilename(filetypes=[("SPICE", "*.sp *.cir")])
        if not path: return

        dummy_data = {'voltage_range': {'typ': '3.3'}, 'rload': '50 ohms', 'sim_time': '6ns'}
        try:
            parsed = parse_netlist(path, dummy_data)
            self.log(f"SPICE loaded: {Path(path).name} → {len(parsed['pins'])} pins", "success")
            self.populate_from_parsed(parsed)
            self.update_yaml()
        except Exception as e:
            messagebox.showerror("Error", f"parse_netlist failed:\n{e}")

    def populate_from_parsed(self, parsed):
        self.clear_all_tabs()
        for pin in parsed['pins']:
            self.pins_tree.insert("", "end", values=(
                pin['pin_name'], pin['signal_name'], pin['model'],
                pin.get('input_pin', ''), pin.get('enable_pin', '')
            ))
        for model in parsed['models']:
            self.models_tree.insert("", "end", values=(
                model['name'], model['type'],
                model.get('enable', ''), model.get('polarity', 'Non-Inverting')
            ))

    def save(self):
        if not self.current_file:
            self.save_as()
            return
        try:
            content = self.yaml_preview.get(1.0, tk.END).strip() + "\n"
            with open(self.current_file, 'w') as f:
                f.write(content)
            self.modified = False
            self.root.title(f"{Path(self.current_file).name} — s2ibispy YAML Editor")
            self.log("Saved", "success")
        except Exception as e:
            messagebox.showerror("Error", f"Save failed:\n{e}")

    def save_as(self):
        path = filedialog.asksaveasfilename(defaultextension=".yaml", filetypes=[("YAML", "*.yaml")])
        if path:
            self.current_file = path
            self.save()

    def build_global_tab(self):
        f = self.tabs["Global"]
        row = 0
        self.global_vars = {}
        fields = [
            ("IBIS Version", "ibis_version", "3.2"),
            ("File Name (.ibs)", "file_name", "buffer.ibs"),
            ("File Revision", "file_rev", "1.0"),
            ("Sim Time (s)", "sim_time", "6e-9"),
            ("Rload (Ω)", "r_load", "50"),
        ]
        for label, key, default in fields:
            ttk.Label(f, text=label + ":").grid(row=row, column=0, sticky="w", padx=10, pady=5)
            var = tk.StringVar(value=default)
            entry = ttk.Entry(f, textvariable=var, width=30)
            entry.grid(row=row, column=1, padx=10, pady=5)
            self.global_vars[key] = var
            var.trace_add("write", lambda *_, k=key: (self.mark_modified(), self.update_yaml()))
            row += 1

    def build_models_tab(self):
        f = self.tabs["Models"]
        tree = ttk.Treeview(f, columns=("Name", "Type", "Enable", "Polarity"), show="headings")
        tree.heading("Name", text="Model Name")
        tree.heading("Type", text="Type")
        tree.heading("Enable", text="Enable Pin")
        tree.heading("Polarity", text="Polarity")
        tree.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        self.models_tree = tree

        btns = ttk.Frame(f)
        btns.pack(pady=5)
        ttk.Button(btns, text="Add Model", command=lambda: self.add_row(tree, ["driver", "I/O", "oe", "Non-Inverting"])).pack(side=tk.LEFT, padx=5)
        ttk.Button(btns, text="Delete", command=lambda: self.delete_row(tree)).pack(side=tk.LEFT, padx=5)

    def build_component_tab(self):
        f = self.tabs["Component"]
        ttk.Label(f, text="Component: MyBuffer | Manufacturer: Unknown | spiceFile: buffer.sp", font=("Helvetica", 12)).pack(pady=20)

    def build_pins_tab(self):
        f = self.tabs["Pins"]
        tree = ttk.Treeview(f, columns=("Pin", "Signal", "Model", "Input", "Enable"), show="headings")
        for c in tree["columns"]:
            tree.heading(c, text=c)
            tree.column(c, width=150)
        tree.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        self.pins_tree = tree
        tree.bind("<Double-1>", self.edit_cell)

        btns = ttk.Frame(f)
        btns.pack(pady=5)
        ttk.Button(btns, text="Add Pin", command=lambda: self.add_row(tree, ["new", "NEW", "driver", "", ""])).pack(side=tk.LEFT, padx=5)
        ttk.Button(btns, text="Delete", command=lambda: self.delete_row(tree)).pack(side=tk.LEFT, padx=5)

    def build_waveforms_tab(self):
        f = self.tabs["Waveforms"]
        ttk.Label(f, text="Waveform Editor — Full version in v2.0", font=("Helvetica", 16)).pack(pady=100)

    def add_row(self, tree, values):
        tree.insert("", "end", values=values)
        self.mark_modified()
        self.update_yaml()

    def delete_row(self, tree):
        sel = tree.selection()
        if sel:
            tree.delete(sel)
            self.mark_modified()
            self.update_yaml()

    def edit_cell(self, event):
        # In-place editing — will be perfect in final
        pass

if __name__ == "__main__":
    root = tk.Tk()
    app = S2IbispyEditor(root)
    root.mainloop()